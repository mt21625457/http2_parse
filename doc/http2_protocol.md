# HTTP/2 协议核心概念详解

## 1. 介绍：为什么要用 HTTP/2？

HTTP/2 是 HTTP 协议的第二个主要版本，于 2015 年发布。它并非对 HTTP/1.x 的语义重写，核心的请求方法（GET, POST）、状态码（200, 404）、URI 和头字段等概念依然保留。HTTP/2 的主要目标是解决 HTTP/1.x 中存在的性能问题，特别是"队头阻塞"（Head-of-Line Blocking）问题，从而提高 Web 页面的加载速度和网络效率。

其主要改进点是：
- **二进制分帧层**: 这是 HTTP/2 的核心。它将所有传输的信息分割为更小的消息和帧，并采用二进制格式进行编码。
- **多路复用**: 允许在单个 TCP 连接上同时发送和接收多个请求和响应，无需按顺序等待。
- **头部压缩**: 使用 HPACK 算法压缩请求和响应的头信息，减少了传输开销。
- **服务器推送**: 服务器可以主动将客户端需要的资源推送到客户端缓存中，减少了请求的延迟。

## 2. 核心概念：流、消息与帧

为了理解 HTTP/2，必须掌握这三个核心概念的关系：

- **连接 (Connection)**: 指代一个 TCP 连接，是通信的物理载体。
- **流 (Stream)**: 一个虚拟的、双向的字节流，存在于一个 TCP 连接中。每个流都有一个唯一的 ID。一个 TCP 连接上可以承载多个并发的流。
- **消息 (Message)**: 对应于一个逻辑上的 HTTP 请求或响应，由一个或多个帧组成。
- **帧 (Frame)**: HTTP/2 通信的最小单位。每个帧都承载着特定类型的数据，例如 `HEADERS` 帧或 `DATA` 帧。

它们的关系是：**单个 TCP 连接 (Connection) 中可以包含多个并发的流 (Stream)，每个流中传输着属于一个请求或响应的消息 (Message)，而每个消息又由一个或多个帧 (Frame) 组成。**

![HTTP/2 概念关系](https://http2.github.io/images/multiplex.png)

## 3. 二进制分帧 (Binary Framing)

HTTP/1.x 是基于文本的协议，而 HTTP/2 是二进制协议。所有通信都在一个被称为"帧"的二进制结构中进行。

每个 HTTP/2 帧共享一个通用的 9 字节头，其结构如下：

| 字段         | 长度 (字节) | 描述                                       |
|--------------|-------------|--------------------------------------------|
| **Length**   | 3           | 24位无符号整数，表示帧负载 (Payload) 的长度。 |
| **Type**     | 1           | 8位整数，定义了帧的类型。                  |
| **Flags**    | 1           | 8位整数，为特定帧类型保留的布尔标志位。      |
| **R**        | 1 bit       | 保留位，必须为 0。                         |
| **Stream ID**| 31 bits     | 31位无符号整数，表示流的唯一标识符。       |

帧头之后是可变长度的 **帧负载 (Frame Payload)**，其结构和内容由 **Type** 字段决定。

## 4. 常见帧类型 (Frame Types)

- **`DATA`**: 用于传输请求或响应的主体数据。
- **`HEADERS`**: 用于传输请求或响应的头信息。如果头信息过大，无法放入一个帧，则其后必须跟一个或多个 `CONTINUATION` 帧。
- **`PRIORITY`**: 用于指定或重新指定流的优先级。
- **`RST_STREAM`**: 用于立即终止一个流。
- **`SETTINGS`**: 用于在连接建立时，通信双方交换配置参数，例如流量控制窗口大小、最大并发流数量等。
- **`PUSH_PROMISE`**: 用于服务器推送。服务器用它来通知客户端，自己即将推送某个资源。
- **`PING`**: 用于计算往返时间 (RTT)，也可以用来确认连接是否仍然有效。
- **`GOAWAY`**: 用于通知对端停止在该连接上创建新的流，通常在需要正常关闭连接或发生严重错误时使用。
- **`WINDOW_UPDATE`**: 用于实现流量控制。
- **`CONTINUATION`**: 用于延续一个 `HEADERS` 或 `PUSH_PROMISE` 帧序列，当头信息块无法在一个帧内完整发送时使用。

## 5. 多路复用 (Multiplexing)

在 HTTP/1.x 中，如果客户端想同时发起多个请求，必须建立多个 TCP 连接，或者在一个连接中等待前一个响应完成后再发送下一个请求（队头阻塞）。

HTTP/2 的多路复用特性允许在**单个 TCP 连接**上同时处理多个请求和响应。这是通过将不同流的帧交错发送来实现的。当数据到达时，HTTP/2 层会根据每个帧的 **Stream ID** 将其重新组装成完整的消息。这极大地提高了网络资源的利用率，并消除了队头阻塞问题。

## 6. 流量控制 (Flow Control)

由于一个 TCP 连接被多个流共享，需要有一种机制来防止某个流占用过多的网络资源，从而阻塞其他流。这就是流量控制的作用。

HTTP/2 的流量控制是**基于信用的 (Credit-based)**:
- **接收方**会为每个流和整个连接维护一个**接收窗口 (Window)**。
- 接收方通过发送 `WINDOW_UPDATE` 帧来告诉发送方自己还有多少字节的接收能力。
- **发送方**在发送 `DATA` 帧时会消耗其发送窗口。当窗口大小降为 0 时，必须停止发送，直到收到接收方的 `WINDOW_UPDATE` 帧。

这种机制是**逐跳 (hop-by-hop)**的，而不是端到端的。

## 7. 头部压缩 (Header Compression - HPACK)

HTTP/1.x 中，每次请求和响应都会携带大量重复的头信息（如 User-Agent, Accept 等），造成了不必要的开销。

HTTP/2 使用 **HPACK** 算法来解决这个问题：
- **动态表**: 通信双方都会维护和更新一个"动态表"，用于存储之前见过的头字段。后续的传输只需发送字段的索引即可。
- **静态表**: HPACK 还定义了一个包含常用头字段（如 `:method: GET`）的"静态表"，可以直接引用。
- **霍夫曼编码**: 对于新的或不常见的头字段值，使用霍夫曼编码进行压缩。

HPACK 的设计能够有效抵御像 CRIME 这样的压缩攻击。 
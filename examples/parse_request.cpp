#include "http2_connection.h"
#include <iostream>
#include <vector>
#include <fstream>
#include <string>
#include <variant>
#include <algorithm>

/**
 * @file parse_request.cpp
 * @brief Example for parsing a complex HTTP/2 stream using the Http2Connection API.
 * @brief 使用Http2Connection API解析复杂HTTP/2流的示例。
 *
 * This program reads the binary data from `http2_request_complex.bin` (generated by
 * the API-driven serialize example), feeds it into a server-side connection,
 * and uses callbacks to print the details of each parsed frame.
 *
 * 本程序读取由API驱动的序列化示例生成的`http2_request_complex.bin`文件的二进制数据，
 * 将其送入一个服务器端连接，并使用回调函数打印出每个解析到的帧的详细信息。
 */

// Helper function to convert FrameType to string
const char* frame_type_to_string_parser(http2::FrameType type) {
    switch (type) {
        case http2::FrameType::DATA: return "DATA";
        case http2::FrameType::HEADERS: return "HEADERS";
        case http2::FrameType::PRIORITY: return "PRIORITY";
        case http2::FrameType::RST_STREAM: return "RST_STREAM";
        case http2::FrameType::SETTINGS: return "SETTINGS";
        case http2::FrameType::PUSH_PROMISE: return "PUSH_PROMISE";
        case http2::FrameType::PING: return "PING";
        case http2::FrameType::GOAWAY: return "GOAWAY";
        case http2::FrameType::WINDOW_UPDATE: return "WINDOW_UPDATE";
        case http2::FrameType::CONTINUATION: return "CONTINUATION";
        default: return "UNKNOWN";
    }
}


int main() {
    std::cout << "--- API-driven Complex HTTP/2 Stream Parsing ---" << std::endl;

    // 1. Read the binary data from the file.
    const std::string filename = "http2_request_complex.bin";
    std::ifstream input_file(filename, std::ios::binary | std::ios::ate);
    if (!input_file) {
        std::cerr << "Error: Could not open file " << filename << ". "
                  << "Please run the serialize_request example first." << std::endl;
        return 1;
    }

    std::streamsize size = input_file.tellg();
    input_file.seekg(0, std::ios::beg);
    std::vector<std::byte> buffer(size);
    if (!input_file.read(reinterpret_cast<char*>(buffer.data()), size)) {
        std::cerr << "Error: Could not read data from " << filename << "." << std::endl;
        return 1;
    }
    input_file.close();
    std::cout << "Read " << size << " bytes from " << filename << "." << std::endl;

    // 2. Setup a server connection with a generic frame callback.
    http2::Http2Connection server_connection(true); // true for server

    server_connection.set_frame_callback([&](const http2::AnyHttp2Frame& frame) {
        std::cout << "[Callback] Frame Received: Type=" << frame_type_to_string_parser(frame.type())
                  << ", StreamID=" << frame.stream_id()
                  << ", Length=" << frame.length()
                  << ", Flags=" << static_cast<int>(frame.flags()) << std::endl;

        if (const auto* headers_frame = frame.get_if<http2::HeadersFrame>()) {
            std::cout << "  > HEADERS content (first " << headers_frame->headers.size() << " headers shown):" << std::endl;
            std::cout << "    Raw Header Block Fragment Size: " << headers_frame->header_block_fragment.size() << " bytes." << std::endl;
            for (size_t i = 0; i < std::min((size_t)5, headers_frame->headers.size()); ++i) {
                const auto& header = headers_frame->headers[i];
                std::cout << "    " << header.name << ": " << (header.value.length() > 50 ? header.value.substr(0, 50) + "..." : header.value) << std::endl;
            }
        } else if (const auto* data_frame = frame.get_if<http2::DataFrame>()) {
            std::cout << "  > DATA content (Payload size: " << data_frame->data.size() << " bytes)." << std::endl;
        } else if (const auto* settings_frame = frame.get_if<http2::SettingsFrame>()) {
            std::cout << "  > SETTINGS content:" << (settings_frame->settings.empty() ? " (empty)" : "") << std::endl;
        } else if (const auto* continuation_frame = frame.get_if<http2::ContinuationFrame>()) {
             std::cout << "  > CONTINUATION (Header block fragment size: " << continuation_frame->header_block_fragment.size() << " bytes)." << std::endl;
        } else if (const auto* ping_frame = frame.get_if<http2::PingFrame>()) {
            std::cout << "  > PING (Opaque data received)." << std::endl;
        } else if (const auto* wu_frame = frame.get_if<http2::WindowUpdateFrame>()) {
             std::cout << "  > WINDOW_UPDATE (Increment: " << wu_frame->window_size_increment << ")." << std::endl;
        }
    });

    // 3. Process the incoming data, skipping the preface.
    const std::string preface = "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n";
    if (buffer.size() < preface.length()) {
        std::cerr << "Error: Input data is too small to be a valid HTTP/2 stream." << std::endl;
        return 1;
    }

    std::cout << "\nProcessing incoming data (skipping " << preface.length() << " byte preface)..." << std::endl;
    try {
        server_connection.process_incoming_data({buffer.data() + preface.length(), buffer.size() - preface.length()});
    } catch (const std::exception& e) {
        std::cerr << "An exception occurred during processing: " << e.what() << std::endl;
        return 1;
    }

    std::cout << "\nAPI-driven parsing complete." << std::endl;

    return 0;
} 